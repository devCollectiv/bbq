import * as convertImageClient from "./convertImageClient";
import {log} from "./logClient";
import {sanityClient} from "./sanityClient";
import {CSVItemColor, CSVItemType, CSVSize} from "./csvClient";

export type SanityImage = {
  _type: "image"
  asset?: {
    _type?: string
    _id?:string
    url?:string
    _ref?: string
  }
}

export type SanityDesignToProcess = {
  _id?: string
  slug?: string
  title?: string
  basePrice?: number
  imageSrc?: SanityImage
  width?: number
  height?: number
  processThisDesign?: boolean
  designResult?: any
  description?: string
}

export type SanityDesign = {
  _id?: string
  slug?: string
  title?: string
  basePrice?: number
  imageSrc?: SanityImage
  width?: number
  height?: number
  description?: string
}

export type SanityCsvToProcess = {
  objectType?: string
  description?: string
  createdDocuments?: string[]
  csvFile?:any
}

export type SanitySlug = {
  current: string
}

const uploadImageFromURL = async (imageFileUrl:string, designTitle:string): Promise<any> => {
  log("uploadImageFromUrl", "NOTICE", "About to upload image to Sanity from ", imageFileUrl);

  return convertImageClient.fetchImageFromUrl(imageFileUrl).then((imageBuffer)=>{
    return sanityClient.assets
        .upload("image",
            imageBuffer.body,
            {filename: `${designTitle}.png`})
        .then((imageAsset:any) => {
          return imageAsset;
        }).catch((e: any)=>{
          log("uploadImageFromUrl", "ERROR", "uploading file error ", e);
        });
  });
};

const createSanityDesign = (designRequest: SanityDesignToProcess, sanityImageAsset: any) =>{
  log("createSanityDesign", "NOTICE", "uploaded an image result: ", sanityImageAsset);
  const newDesign: SanityDesign = {
    imageSrc: {
      _type: "image",
      asset: {
        _type: "reference",
        _ref: sanityImageAsset._id ?? "",
      },
    },
    slug: designRequest.slug ?? "",
    title: designRequest.title ?? "",
    basePrice: designRequest.basePrice ?? 0,
    description: designRequest.description ?? "",
    width: designRequest.width ?? 0,
    height: designRequest.height ?? 0,
  };

  log("createSanityDesign", "NOTICE", "potential design ", newDesign);

  return sanityClient.create({
    _type: "design",
    ...newDesign,
  });
};

const createSanityDocument = async (document: CSVItemColor|CSVSize|CSVItemType, sanityType: string) =>{
  const newSanityDocument = {
    _type: sanityType,
    isAutoGenerated: true,
    ...document,
    slug: document.slug ? {current: document.slug ?? ""}: undefined,
  };

  log("createSanityItemDocument", "NOTICE", "processing sanity document", document);

  if (!document.slug || !sanityType) {
    log("createSanityItemDocument", "ERROR", "Can't process this document", {document, sanityType});

    // eslint-disable-next-line prefer-promise-reject-errors
    return Promise.reject();
  }

  const foundItem:any = await sanityClient
      .fetch(
          "*[_type == $type && slug.current == $slug]", {slug: document.slug, type: sanityType}).then((data: any[]) => data[0]);

  if (foundItem) {
    log("createSanityItemDoc", "NOTICE", "updating document with slug: ", {foundItem, slug: document.slug, type: sanityType, potentialDocument: newSanityDocument});

    return sanityClient.patch(foundItem._id).set({
      ...newSanityDocument,
    }).commit();
  } else {
    log("createSanityItemDoc", "NOTICE", "creating document with slug ", newSanityDocument);

    return sanityClient.create({
      ...newSanityDocument,
    });
  }
};

const updateDesignToProcess = (designReq:SanityDesignToProcess, designResult: SanityDesign) =>{
  const designToProcessUpdateReq = {
    designResult: {
      _type: "reference",
      _ref: designResult._id,
    },
    processThisDesign: false,
  };

  log("updateDesignToProcess", "NOTICE", "Updating Design Creation Request", designToProcessUpdateReq);

  return sanityClient
      .patch(designReq._id)
      .set({
        ...designToProcessUpdateReq,
      },
      )
      .commit();
};

export {createSanityDocument, uploadImageFromURL, createSanityDesign, updateDesignToProcess};
